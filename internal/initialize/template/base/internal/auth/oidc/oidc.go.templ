package oidc

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"sync"

	"{{ .Name }}/internal/auth/oauth"

	oidclib "github.com/coreos/go-oidc/v3/oidc"
	"golang.org/x/oauth2"
)

var (
	ErrProviderNotFound = errors.New("oidc: provider not found")
	ErrNonceMismatch    = errors.New("oidc: nonce mismatch")
)

var (
	oidcProviderCache = make(map[string]*oidclib.Provider)
	oidcProviderMu    sync.RWMutex
)

func getOrCreateOIDCProvider(ctx context.Context, issuer string) (*oidclib.Provider, error) {
	oidcProviderMu.RLock()
	provider, exists := oidcProviderCache[issuer]
	oidcProviderMu.RUnlock()

	if exists {
		return provider, nil
	}

	oidcProviderMu.Lock()
	defer oidcProviderMu.Unlock()

	if provider, exists := oidcProviderCache[issuer]; exists {
		return provider, nil
	}

	provider, err := oidclib.NewProvider(ctx, issuer)
	if err != nil {
		return nil, err
	}

	oidcProviderCache[issuer] = provider
	return provider, nil
}

type VerifyFunc func(ctx context.Context, idToken string, clientID string) (*IDTokenClaims, error)

type IDTokenClaims struct {
	Issuer         string `json:"iss"`
	Subject        string `json:"sub"`
	Audience       string `json:"aud"`
	AudienceRaw    any    `json:"-"`
	ExpirationTime int64  `json:"exp"`
	IssuedAt       int64  `json:"iat"`
	AuthTime       int64  `json:"auth_time,omitempty"`
	Nonce          string `json:"nonce,omitempty"`

	Name              string `json:"name,omitempty"`
	GivenName         string `json:"given_name,omitempty"`
	FamilyName        string `json:"family_name,omitempty"`
	MiddleName        string `json:"middle_name,omitempty"`
	Nickname          string `json:"nickname,omitempty"`
	PreferredUsername string `json:"preferred_username,omitempty"`
	Profile           string `json:"profile,omitempty"`
	Picture           string `json:"picture,omitempty"`
	Website           string `json:"website,omitempty"`
	Gender            string `json:"gender,omitempty"`
	Birthdate         string `json:"birthdate,omitempty"`
	Zoneinfo          string `json:"zoneinfo,omitempty"`
	Locale            string `json:"locale,omitempty"`
	UpdatedAt         int64  `json:"updated_at,omitempty"`

	Email         string `json:"email,omitempty"`
	EmailVerified bool   `json:"email_verified,omitempty"`

	AdditionalClaims map[string]any `json:"-"`

	RawToken string `json:"-"`
}

type Registry struct {
	providers map[string]*Provider
}

func NewRegistry(providers map[string]*Provider) *Registry {
	return &Registry{
		providers: providers,
	}
}

func (r *Registry) Get(name string) (*Provider, bool) {
	provider, exists := r.providers[name]
	return provider, exists
}

func (r *Registry) Names() []string {
	names := make([]string, 0, len(r.providers))
	for name := range r.providers {
		names = append(names, name)
	}
	return names
}

type Provider struct {
	oauth      *oauth.Provider
	issuer     string
	clientID   string
	extraOpts  map[string]string
	verifyFunc VerifyFunc
}

func NewProvider(oauthProvider *oauth.Provider, issuer, clientID string, extraOpts map[string]string) *Provider {
	return &Provider{
		oauth:     oauthProvider,
		issuer:    issuer,
		clientID:  clientID,
		extraOpts: extraOpts,
	}
}

func (p *Provider) WithCustomVerify(fn VerifyFunc) *Provider {
	p.verifyFunc = fn
	return p
}

func (p *Provider) AuthURL(state, nonce string) string {
	authURL := p.oauth.AuthURL(state)

	u, err := url.Parse(authURL)
	if err != nil {
		return authURL + "&nonce=" + url.QueryEscape(nonce)
	}

	q := u.Query()
	q.Set("nonce", nonce)

	for key, value := range p.extraOpts {
		q.Set(key, value)
	}

	u.RawQuery = q.Encode()
	return u.String()
}

func (p *Provider) Exchange(ctx context.Context, code string) (*oauth2.Token, error) {
	return p.oauth.Exchange(ctx, code)
}

func (p *Provider) UserInfo(ctx context.Context, token *oauth2.Token) (any, error) {
	return p.oauth.UserInfo(ctx, token)
}

func (p *Provider) VerifyIDToken(ctx context.Context, idToken string) (*IDTokenClaims, error) {
	if p.verifyFunc != nil {
		return p.verifyFunc(ctx, idToken, p.clientID)
	}
	return verifyIDToken(ctx, idToken, p.issuer, p.clientID)
}

func (p *Provider) RedirectURL() string {
	return p.oauth.RedirectURL()
}

func verifyIDToken(ctx context.Context, idToken string, issuer string, clientID string) (*IDTokenClaims, error) {
	provider, err := getOrCreateOIDCProvider(ctx, issuer)
	if err != nil {
		return nil, fmt.Errorf("failed to get OIDC provider: %w", err)
	}

	verifier := provider.Verifier(&oidclib.Config{ClientID: clientID})

	idTokenVerified, err := verifier.Verify(ctx, idToken)
	if err != nil {
		return nil, fmt.Errorf("failed to verify ID token signature: %w", err)
	}

	claims, err := ParseIDToken(idToken)
	if err != nil {
		return nil, err
	}

	if err := ValidateBasicClaims(claims, issuer, clientID, ""); err != nil {
		return nil, err
	}

	if idTokenVerified.Subject != claims.Subject {
		return nil, ErrInvalidToken
	}

	return claims, nil
}