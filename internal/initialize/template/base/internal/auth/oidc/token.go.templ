package oidc

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"
)

const (
	DefaultClockSkew      = 5 * time.Minute
	MaxTokenLifetime      = 24 * time.Hour
)

var (
	ErrInvalidToken       = errors.New("oidc: invalid token format")
	ErrTokenExpired       = errors.New("oidc: token has expired")
	ErrInvalidIssuer      = errors.New("oidc: invalid issuer")
	ErrInvalidAudience    = errors.New("oidc: invalid audience")
	ErrInvalidNonce       = errors.New("oidc: invalid nonce")
	ErrInvalidSignature   = errors.New("oidc: invalid token signature")
	ErrInvalidIssuedAt    = errors.New("oidc: invalid issued at time")
	ErrMissingSubject     = errors.New("oidc: missing subject claim")
	ErrTokenTooLongLived  = errors.New("oidc: token lifetime exceeds maximum")
)

func ParseIDToken(idToken string) (*IDTokenClaims, error) {
	parts := strings.Split(idToken, ".")
	if len(parts) != 3 {
		return nil, ErrInvalidToken
	}

	payloadJSON, err := base64.RawURLEncoding.DecodeString(parts[1])
	if err != nil {
		return nil, fmt.Errorf("failed to decode token payload: %w", err)
	}

	var claims IDTokenClaims
	if err := json.Unmarshal(payloadJSON, &claims); err != nil {
		return nil, fmt.Errorf("failed to parse token claims: %w", err)
	}

	claims.RawToken = idToken

	var rawMap map[string]any
	if err := json.Unmarshal(payloadJSON, &rawMap); err != nil {
		return nil, fmt.Errorf("failed to parse token claims for raw audience: %w", err)
	}
	claims.AudienceRaw = rawMap["aud"]

	return &claims, nil
}

func ValidateBasicClaims(claims *IDTokenClaims, expectedIssuer, expectedAudience, expectedNonce string) error {
	return ValidateBasicClaimsWithSkew(claims, expectedIssuer, expectedAudience, expectedNonce, DefaultClockSkew)
}

func ValidateBasicClaimsWithSkew(claims *IDTokenClaims, expectedIssuer, expectedAudience, expectedNonce string, clockSkew time.Duration) error {
	now := time.Now()

	if claims.Subject == "" {
		return ErrMissingSubject
	}

	if now.Unix() > claims.ExpirationTime+int64(clockSkew.Seconds()) {
		return ErrTokenExpired
	}

	if claims.IssuedAt > 0 {
		if now.Unix()+int64(clockSkew.Seconds()) < claims.IssuedAt {
			return ErrInvalidIssuedAt
		}
	}

	if claims.ExpirationTime > 0 && claims.IssuedAt > 0 {
		tokenLifetime := time.Duration(claims.ExpirationTime-claims.IssuedAt) * time.Second
		if tokenLifetime > MaxTokenLifetime {
			return ErrTokenTooLongLived
		}
	}

	if expectedIssuer != "" && claims.Issuer != expectedIssuer {
		return ErrInvalidIssuer
	}

	if expectedAudience != "" {
		if claims.Audience != expectedAudience {
			audienceArray, ok := claims.AudienceRaw.([]any)
			if !ok {
				return ErrInvalidAudience
			}

			found := false
			for _, aud := range audienceArray {
				if audStr, ok := aud.(string); ok && audStr == expectedAudience {
					found = true
					break
				}
			}

			if !found {
				return ErrInvalidAudience
			}
		}
	}

	if expectedNonce != "" && claims.Nonce != expectedNonce {
		return ErrInvalidNonce
	}

	return nil
}

func GenerateRandomToken() (string, error) {
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return "", fmt.Errorf("oidc: failed to generate random token: %w", err)
	}
	return base64.URLEncoding.EncodeToString(b), nil
}