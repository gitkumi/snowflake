package oauth

import (
	"context"
	"fmt"
	"strings"

	"golang.org/x/oauth2"
)

var LinkedInEndpoint = oauth2.Endpoint{
	AuthURL:  "https://www.linkedin.com/oauth/v2/authorization",
	TokenURL: "https://www.linkedin.com/oauth/v2/accessToken",
}

const (
	LinkedInUserInfoURL = "https://api.linkedin.com/v2/me"
	LinkedInEmailURL    = "https://api.linkedin.com/v2/emailAddress?q=members&projection=(elements*(handle~))"
)

func NewLinkedInProvider(config *oauth2.Config) *Provider {
	config.Endpoint = LinkedInEndpoint
	providerConfig := ProviderConfig{
		RequirePKCE: false,
		Scopes:      []string{"r_liteprofile", "r_emailaddress"},
	}
	return NewProvider("linkedin", config, fetchLinkedInUserInfo, providerConfig)
}

type LinkedInUserInfo struct {
	ID            string `json:"id"`
	Email         string `json:"email"`
	EmailVerified bool   `json:"email_verified"`
	FirstName     string `json:"first_name"`
	LastName      string `json:"last_name"`
	PictureURL    string `json:"picture_url"`
	Locale        string `json:"locale"`
	Provider      string `json:"provider"`
}

func fetchLinkedInUserInfo(ctx context.Context, config *oauth2.Config, token *oauth2.Token) (any, error) {
	var userResp struct {
		ID        string `json:"id"`
		FirstName struct {
			Localized       map[string]string `json:"localized"`
			PreferredLocale struct {
				Country  string `json:"country"`
				Language string `json:"language"`
			} `json:"preferredLocale"`
		} `json:"firstName"`
		LastName struct {
			Localized       map[string]string `json:"localized"`
			PreferredLocale struct {
				Country  string `json:"country"`
				Language string `json:"language"`
			} `json:"preferredLocale"`
		} `json:"lastName"`
		ProfilePicture struct {
			DisplayImage struct {
				Elements []struct {
					Identifiers []struct {
						Identifier string `json:"identifier"`
					} `json:"identifiers"`
				} `json:"elements"`
			} `json:"displayImage~"`
		} `json:"profilePicture"`
	}

	if err := FetchUserInfo(ctx, config, token, LinkedInUserInfoURL, &userResp); err != nil {
		return nil, err
	}

	locale := fmt.Sprintf("%s_%s", userResp.FirstName.PreferredLocale.Language, userResp.FirstName.PreferredLocale.Country)
	firstName := ""
	lastName := ""

	for k, v := range userResp.FirstName.Localized {
		if strings.HasPrefix(k, userResp.FirstName.PreferredLocale.Language) {
			firstName = v
			break
		}
	}

	for k, v := range userResp.LastName.Localized {
		if strings.HasPrefix(k, userResp.LastName.PreferredLocale.Language) {
			lastName = v
			break
		}
	}

	picture := ""
	if len(userResp.ProfilePicture.DisplayImage.Elements) > 0 {
		if len(userResp.ProfilePicture.DisplayImage.Elements[0].Identifiers) > 0 {
			picture = userResp.ProfilePicture.DisplayImage.Elements[0].Identifiers[0].Identifier
		}
	}

	userInfo := &LinkedInUserInfo{
		ID:            userResp.ID,
		FirstName:     firstName,
		LastName:      lastName,
		PictureURL:    picture,
		Locale:        locale,
		EmailVerified: true,
		Provider:      "linkedin",
	}

	if err := enrichLinkedInUserInfoWithEmail(ctx, config, token, userInfo); err != nil {
		return nil, err
	}

	return userInfo, nil
}

func enrichLinkedInUserInfoWithEmail(ctx context.Context, config *oauth2.Config, token *oauth2.Token, userInfo *LinkedInUserInfo) error {
	var emailResp struct {
		Elements []struct {
			Handle struct {
				EmailAddress string `json:"emailAddress"`
			} `json:"handle~"`
		} `json:"elements"`
	}

	if err := FetchUserInfo(ctx, config, token, LinkedInEmailURL, &emailResp); err != nil {
		return err
	}

	if len(emailResp.Elements) > 0 {
		userInfo.Email = emailResp.Elements[0].Handle.EmailAddress
	}

	return nil
}
