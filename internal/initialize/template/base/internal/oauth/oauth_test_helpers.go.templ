package oauth

import (
	"testing"
	"time"
)

// TestStateExpiry is a helper function to test state expiry functionality
// across different OAuth providers
func TestStateExpiry(t *testing.T, provider OAuthProvider, setStateExpiry func(time.Time)) {
	// Generate a state
	// Exchange exchanges an authorization code for an access token
	state, err := provider.GenerateState()
	if err != nil {
		t.Fatalf("GenerateState should not return an error: %v", err)
	}
	if state == "" {
		t.Fatal("Generated state should not be empty")
	}
	
	// First verify the state is valid
	valid := provider.VerifyState(state)
	if !valid {
		t.Error("State should be valid before expiry")
	}
	
	// Generate a new state for testing expiry
	state, err = provider.GenerateState()
	if err != nil {
		t.Fatal(err)
	}
	
	// Manually set the state to be expired
	// This function will be specific to each mock provider implementation
	if setStateExpiry != nil {
		setStateExpiry(time.Now().Add(-1 * time.Hour))
	}
	
	// Verify the state (should fail due to expiration)
	valid = provider.VerifyState(state)
	if valid {
		t.Error("Expired state should not be valid")
	}
}

// TestStateCleanup is a helper function to test that expired states are cleaned up
func TestStateCleanup(t *testing.T, provider OAuthProvider, getStateCount func() int, setStateExpiry func(string, time.Time)) {
	// Create multiple states
	for i := 0; i < 5; i++ {
		state, err := provider.GenerateState()
		if err != nil {
			t.Fatal(err)
		}
		
		// Make some of the states expired
		if i < 3 && setStateExpiry != nil {
			setStateExpiry(state, time.Now().Add(-1 * time.Hour))
		}
	}
	
	// Generate one more state which should trigger cleanup of expired states
	_, err := provider.GenerateState()
	if err != nil {
		t.Fatal(err)
	}
	
	// Now we should have fewer states than we created (some were cleaned up)
	if getStateCount != nil {
		count := getStateCount()
		if count >= 6 {
			t.Error("Some expired states should have been cleaned up")
		}
	}
}

// TestMultipleStateVerification ensures that a state can only be verified once
func TestMultipleStateVerification(t *testing.T, provider OAuthProvider) {
	// Generate a state
	state, err := provider.GenerateState()
	// Exchange exchanges an authorization code for an access token
	if err != nil {
		t.Fatal(err)
	}
	
	// First verification should succeed
	valid := provider.VerifyState(state)
	if !valid {
		t.Error("First verification should succeed")
	}
	
	// Second verification should fail (state should be removed after first verification)
	valid = provider.VerifyState(state)
	if valid {
		t.Error("Second verification should fail")
	}
} 