package application

import (
	"{{ .Name }}/internal/application/handler"
	"{{ .Name }}/internal/application/service"
	"{{ .Name }}/internal/env"
	{{- if ne .Database.String "none" }}
	"database/sql"
	"{{ .Name }}/internal/repo"
	{{- end }}
	{{- if .SMTP }}
	"{{ .Name }}/internal/smtp"
	{{- end }}
	{{- if .WithOAuth }}
	"{{ .Name }}/internal/oauth"
	{{- end }}
	{{- if .Storage }}
	"{{ .Name }}/internal/storage"
	{{- end }}
	{{- if .Redis }}
	"github.com/redis/go-redis/v9"
	{{- end }}
	{{- if eq .BackgroundJob "sqs" }}
	"acme/internal/queue"
	{{- else if eq .BackgroundJob "asynq" }}
	"github.com/hibiken/asynq"
	{{- else if eq .BackgroundJob "basic" }}
	"sync"
	{{- end }}
	"context"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"net/http"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
)

type Handlers struct {
	{{- if ne .Database.String "none" }}
	book   *handler.BookHandler
		{{- if and .SMTP .Auth }}
	auth   *handler.AuthHandler
		{{- end }}
	{{- end }}
	health *handler.HealthHandler
	{{- if eq .AppType "web"}}
	html   *handler.HTMLHandler
	{{- end }}
}

type Application struct {
	Environment env.Environment
	baseURL  string
	port     int
	{{- if eq .BackgroundJob "basic" }}
	wg       sync.WaitGroup
	{{- end }}
	handlers *Handlers

	Logger  *slog.Logger
	Router  *gin.Engine
	{{- if .SMTP }}
	Mailer  smtp.Mailer
	{{- end }}
	{{- if .Storage }}
	Storage storage.Storage
	{{- end }}
	{{- if .WithOAuth }}
	oauth  *handler.OAuthHandler
	{{- end }}
}

type Config struct {
	BaseURL string
	Port    int
	Router  *gin.Engine
	{{- if ne .Database.String "none" }}
	DB      *sql.DB
	{{- end }}
	{{- if .SMTP }}
	Mailer  smtp.Mailer
	{{- end }}
	{{- if .Storage }}
	Storage storage.Storage
	{{- end }}
	Logger      *slog.Logger
	Environment env.Environment
	{{- if .Redis }}
	Redis *redis.Client
	{{- end }}
	{{- if eq .BackgroundJob "sqs" }}
	Queue   queue.Queue
	{{- else if eq .BackgroundJob "asynq" }}
	Asynq   *asynq.Client
	{{- end }}

	{{- if .OAuthGoogle }}GoogleOAuth    oauth.OAuthProvider{{- end }}
	{{- if .OAuthFacebook }}FacebookOAuth  oauth.OAuthProvider{{- end }}
	{{- if .OAuthGitHub }}GitHubOAuth    oauth.OAuthProvider{{- end }}
	{{- if .OAuthLinkedIn }}LinkedInOAuth  oauth.OAuthProvider{{- end }}
	{{- if .OAuthInstagram }}InstagramOAuth oauth.OAuthProvider{{- end }}
	{{- if .OAuthDiscord }}DiscordOAuth   oauth.OAuthProvider{{- end }}
}

func New(cfg *Config) (*Application, error) {
	// Inject these to service when needed:
	{{- if ne .Database "none" }}
	// cfg.DB
	{{- end }}
	{{- if .Redis }}
	// cfg.Redis
	{{- end }}
	{{- if eq .BackgroundJob "sqs" }}
	// cfg.Queue
	{{- else if eq .BackgroundJob "asynq" }}
	// cfg.Asynq
	{{- end }}

	{{- if ne .Database.String "none" }}
	query := repo.New(cfg.DB)

	bookService := service.NewBookService(query)
	bookHandler := handler.NewBookHandler(bookService)

		{{- if and .SMTP .Auth }}
	authService := service.NewAuthService(cfg.BaseURL, query, cfg.Mailer, cfg.DB)
	authHandler := handler.NewAuthHandler(authService)
		{{- end }}
	{{- end }}

	{{- if .WithOAuth }}
	oauthService := service.NewOAuthService(
		cfg.BaseURL,
		cfg.DB,
		query,
		{{- if .OAuthGoogle }}cfg.GoogleOAuth,{{- end }}
		{{- if .OAuthFacebook }}cfg.FacebookOAuth,{{- end }}
		{{- if .OAuthGitHub }}cfg.GitHubOAuth,{{- end }}
		{{- if .OAuthLinkedIn }}cfg.LinkedInOAuth,{{- end }}
		{{- if .OAuthInstagram }}cfg.InstagramOAuth,{{- end }}
		{{- if .OAuthDiscord }}cfg.DiscordOAuth,{{- end }}
	)
	oauthHandler := handler.NewOAuthHandler(oauthService)
	{{- end }}

	{{- if .Storage }}
		{{- if ne .Database.String "none" }}
	healthService := service.NewHealthService(cfg.DB, cfg.Storage)
		{{- else }}
	healthService := service.NewHealthService(cfg.Storage)
		{{- end }}
	{{- else }}
		{{- if ne .Database.String "none" }}
	healthService := service.NewHealthService(cfg.DB)
		{{- else }}
	healthService := service.NewHealthService()
		{{- end }}
	{{- end }}

	healthHandler := handler.NewHealthHandler(healthService)

	{{- if eq .AppType "web"}}
	htmlHandler := handler.NewHTMLHandler()
	{{- end }}

	handlers := &Handlers{
		{{- if ne .Database.String "none" }}
		book: bookHandler,
		{{- end }}
		{{- if and .SMTP .Auth}}
		auth:   authHandler,
		{{- end }}
		health: healthHandler,
		{{- if eq .AppType "web"}}
		html:   htmlHandler,
		{{- end }}
		{{- if .WithOAuth }}
		oauth:  oauthHandler
		{{- end }}
	}

	s := &Application{
		Environment: cfg.Environment,
		baseURL:  cfg.BaseURL,
		Logger:   cfg.Logger,
		Router:   cfg.Router,
		handlers: handlers,
		port:			cfg.Port,
	}

	{{- if .Redis }}
	err := s.registerRoutes(cfg.Redis)
	{{- else }}
	err := s.registerRoutes()
	{{- end }}
	if err != nil {
		return nil, err
	}

	return s, nil
}

func (app *Application) Run() {
	srv := &http.Server{
		Addr:    ":" + strconv.Itoa(app.port),
		Handler: app.Router,
	}

	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	go func() {
		<-ctx.Done()

		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		if err := srv.Shutdown(shutdownCtx); err != nil {
			log.Println("server shutdown: ", err)
		}
	}()

	fmt.Printf("\nServer started at http://%s:%d", app.baseURL, app.port)
	if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Println("listen and serve error: ", err)
	}

	{{- if eq .BackgroundJob "basic" }}
	app.wg.Wait()
	{{- end }}
}
