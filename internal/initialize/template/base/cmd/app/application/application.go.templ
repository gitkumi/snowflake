package application

import (
	"{{ .Name }}/cmd/app/service"
	"{{ .Name }}/cmd/app/handler"
	"{{ .Name }}/internal/env"
	"context"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"net/http"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	{{- if ne .Database.String "none" }}
	"database/sql"
	"{{ .Name }}/cmd/app/repo"
	{{- end }}
	{{- if .SMTP }}
	"{{ .Name }}/internal/smtp"
	{{- end }}
	{{- if .Storage }}
	"{{ .Name }}/internal/storage"
	{{- end }}
	{{- if .Redis }}
	"github.com/redis/go-redis/v9"
	{{- end }}
	{{- if eq .Queue "sqs" }}
	"{{ .Name }}/internal/queue"
	{{- end }}
)

type Handlers struct {
	health *handler.HealthHandler
	{{- if ne .Database.String "none" }}
	book   *handler.BookHandler
	{{- end }}
	{{- if .ServeHTML }}
	html   *handler.HTMLHandler
	{{- end }}
}

type Application struct {
	Environment env.Environment
	baseURL  string
	port     int
	handlers *Handlers

	Logger  *slog.Logger
	Router  *gin.Engine
}

type Config struct {
	BaseURL                  string
	Port                     int
	Router                   *gin.Engine
	Logger                   *slog.Logger
	Environment              env.Environment
{{- if ne .Database.String "none" }}
	DB                       *sql.DB
{{- end }}
{{- if .SMTP }}
	Mailer                   smtp.Mailer
{{- end }}
{{- if .Storage }}
	Storage                  storage.Storage
{{- end }}
{{- if .Redis }}
	Redis                    *redis.Client
{{- end }}
{{- if eq .Queue "sqs" }}
	Queue                    queue.Queue
{{- end }}
}

func NewApplication(cfg *Config) (*Application, error) {
{{- if ne .Database.String "none" }}
	query := repo.New(cfg.DB)

	bookService := service.NewBookService(query)
	bookHandler := handler.NewBookHandler(bookService)
	{{- end }}

	healthService := service.NewHealthService(
		{{- if ne .Database.String "none" }}cfg.DB,{{- end }}
		{{- if .Storage }}cfg.Storage,{{- end }}
		{{- if .Redis }}cfg.Redis,{{- end }}
	)
	healthHandler := handler.NewHealthHandler(healthService)

	{{- if .ServeHTML }}
	htmlHandler := handler.NewHTMLHandler()
	{{- end }}

	handlers := &Handlers{
		health: healthHandler,
		{{- if ne .Database.String "none" }}
		book: bookHandler,
		{{- end }}
		{{- if .ServeHTML }}
		html: htmlHandler,
		{{- end }}
	}

	s := &Application{
		Environment: cfg.Environment,
		baseURL:  cfg.BaseURL,
		Logger:   cfg.Logger,
	Router:   cfg.Router,
	handlers: handlers,
	port:			cfg.Port,
}

	err := s.RegisterRoutes()
	if err != nil {
		return nil, err
	}

	return s, nil
}

func (app *Application) Run() {
	srv := &http.Server{
		Addr:    ":" + strconv.Itoa(app.port),
		Handler: app.Router,
	}

	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	go func() {
		<-ctx.Done()

		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		if err := srv.Shutdown(shutdownCtx); err != nil {
			log.Println("server shutdown: ", err)
		}
	}()

	fmt.Printf("\nServer started at http://%s:%d", app.baseURL, app.port)
	if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Println("listen and serve error: ", err)
	}
}
