package application

import (
	"{{ .Name }}/cmd/app/service"
	"{{ .Name }}/cmd/app/handler"
	"{{ .Name }}/internal/env"
	"context"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"net/http"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	{{- if ne .Database.String "none" }}
	"database/sql"
	"{{ .Name }}/cmd/app/repo"
	{{- end }}
	{{- if .SMTP }}
	"{{ .Name }}/internal/smtp"
	{{- end }}
	{{- if .Storage }}
	"{{ .Name }}/internal/storage"
	{{- end }}
	{{- if .Redis }}
	"github.com/redis/go-redis/v9"
	{{- end }}
	{{- if eq .Queue "sqs" }}
	"{{ .Name }}/internal/queue"
	{{- end }}

	{{- if or .HasOAuth .HasOIDC }}
	"{{ .Name }}/internal/auth"
	{{- end }}
	{{- if .HasOAuth }}
	"{{ .Name }}/internal/auth/oauth"
	{{- end }}

	{{- if .HasOIDC }}
	"{{ .Name }}/internal/auth/oidc"
	{{- end }}

	{{- if eq .Billing.String "stripe" }}
	"{{ .Name }}/internal/billing"
	{{- end }}
)

type Handlers struct {
	health *handler.HealthHandler
	{{- if ne .Database.String "none" }}
	book   *handler.BookHandler
	{{- end }}
	{{- if .ServeHTML }}
	html   *handler.HTMLHandler
	{{- end }}

	{{- if .HasOAuth }}
	oauth  *handler.OAuthHandler
	{{- end }}

	{{- if .HasOIDC }}
	oidc   *handler.OIDCHandler
	{{- end }}

	{{- if eq .Billing.String "stripe" }}
	billing *handler.BillingHandler
	webhook *handler.WebhookHandler
	{{- end }}
}

type Application struct {
	Environment env.Environment
	baseURL  string
	port     int
	handlers *Handlers

	Logger  *slog.Logger
	Router  *gin.Engine
}

type Config struct {
	BaseURL                  string
	Port                     int
	Router                   *gin.Engine
	Logger                   *slog.Logger
	Environment              env.Environment
{{- if ne .Database.String "none" }}
	DB                       *sql.DB
{{- end }}
{{- if .SMTP }}
	Mailer                   smtp.Mailer
{{- end }}
{{- if .Storage }}
	Storage                  storage.Storage
{{- end }}
{{- if .Redis }}
	Redis                    *redis.Client
{{- end }}
{{- if eq .Queue "sqs" }}
	Queue                    queue.Queue
{{- end }}
{{- if .HasOAuth }}
	OAuth                    *oauth.Registry
{{- end }}
{{- if .HasOIDC }}
	OIDC                     *oidc.Registry
{{- end }}
{{- if .HasOAuth }}
	OAuthAllowedRedirectURLs []string
{{- end }}
{{- if .HasOAuth }}
	JWTManager               *auth.JWTManager
{{- end }}
{{- if .HasOAuth }}
	SessionMaxAge            int
{{- end }}
{{- if eq .Billing.String "stripe" }}
	Billing                  billing.Billing
	StripeWebhookSecret      string
{{- end }}
}

func NewApplication(cfg *Config) (*Application, error) {
{{- if ne .Database.String "none" }}
	query := repo.New(cfg.DB)

	bookService := service.NewBookService(query)
	bookHandler := handler.NewBookHandler(bookService)
	{{- end }}

	healthService := service.NewHealthService(
		{{- if ne .Database.String "none" }}cfg.DB,{{- end }}
		{{- if .Storage }}cfg.Storage,{{- end }}
		{{- if .Redis }}cfg.Redis,{{- end }}
	)
	healthHandler := handler.NewHealthHandler(healthService)

	{{- if .ServeHTML }}
	htmlHandler := handler.NewHTMLHandler()
	{{- end }}

	{{- if .HasOAuth }}
	oauthService := service.NewOAuthService(cfg.OAuth, cfg.Logger)
	oauthHandler := handler.NewOAuthHandler(
		oauthService,
		cfg.Environment,
		cfg.OAuthAllowedRedirectURLs,
		cfg.JWTManager,
		cfg.SessionMaxAge,
		cfg.Logger,
	)
{{- end }}

{{- if .HasOIDC }}
	oidcService := service.NewOIDCService(cfg.OIDC, cfg.Logger)
	oidcHandler := handler.NewOIDCHandler(
		oidcService,
		cfg.Environment,
		cfg.OAuthAllowedRedirectURLs,
		cfg.JWTManager,
		cfg.SessionMaxAge,
		cfg.Logger,
	)
{{- end }}

	{{- if eq .Billing.String "stripe" }}
	billingService := service.NewBillingService(cfg.Billing)
	billingHandler := handler.NewBillingHandler(billingService)
	webhookHandler := handler.NewWebhookHandler(cfg.StripeWebhookSecret)
	{{- end }}

	handlers := &Handlers{
		health: healthHandler,
		{{- if ne .Database.String "none" }}
		book: bookHandler,
		{{- end }}
		{{- if .ServeHTML }}
		html: htmlHandler,
		{{- end }}
		{{- if .HasOAuth }}
		oauth: oauthHandler,
		{{- end }}
		{{- if .HasOIDC }}
		oidc: oidcHandler,
		{{- end }}
		{{- if eq .Billing.String "stripe" }}
		billing: billingHandler,
		webhook: webhookHandler,
		{{- end }}
	}

	s := &Application{
		Environment: cfg.Environment,
		baseURL:  cfg.BaseURL,
		Logger:   cfg.Logger,
	Router:   cfg.Router,
	handlers: handlers,
	port:			cfg.Port,
}

	err := s.RegisterRoutes()
	if err != nil {
		return nil, err
	}

	return s, nil
}

func (app *Application) Run() {
	srv := &http.Server{
		Addr:    ":" + strconv.Itoa(app.port),
		Handler: app.Router,
	}

	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	go func() {
		<-ctx.Done()

		shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		if err := srv.Shutdown(shutdownCtx); err != nil {
			log.Println("server shutdown: ", err)
		}
	}()

	fmt.Printf("\nServer started at http://%s:%d", app.baseURL, app.port)
	if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Println("listen and serve error: ", err)
	}
}
