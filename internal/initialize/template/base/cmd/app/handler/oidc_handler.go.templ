package handler

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"net/url"
	"{{ .Name }}/cmd/app/service"
	"{{ .Name }}/internal/auth"
	"{{ .Name }}/internal/auth/oidc"
	"{{ .Name }}/internal/env"
	"time"

	"github.com/gin-gonic/gin"
)

type OIDCHandler struct {
	Service             *service.OIDCService
	Environment         env.Environment
	AllowedRedirectURLs []string
	JWTManager          *auth.JWTManager
	SessionMaxAge       int
	Logger              *slog.Logger
}

func NewOIDCHandler(s *service.OIDCService, environment env.Environment, allowedRedirectURLs []string, jwtManager *auth.JWTManager, sessionMaxAge int, logger *slog.Logger) *OIDCHandler {
	return &OIDCHandler{
		Service:             s,
		Environment:         environment,
		AllowedRedirectURLs: allowedRedirectURLs,
		JWTManager:          jwtManager,
		SessionMaxAge:       sessionMaxAge,
		Logger:              logger,
	}
}

func (h *OIDCHandler) Authorize(c *gin.Context) {
	redirectURL := c.Query("redirect_url")
	if redirectURL == "" {
		h.respondWithError(c, auth.ErrInvalidRequest)
		return
	}

	if err := auth.ValidateRedirectURL(redirectURL, h.AllowedRedirectURLs); err != nil {
		h.Logger.Warn("invalid redirect URL attempted",
			"redirect_url", redirectURL,
			"error", err,
			"ip", c.ClientIP())
		h.respondWithError(c, auth.ErrInvalidRequest)
		return
	}

	providerName := c.Param("provider")

	ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	authURL, nonce, err := h.Service.AuthURL(ctx, providerName)
	if err != nil {
		h.Logger.Error("failed to generate auth URL",
			"provider", providerName,
			"error", err)
		h.respondWithError(c, auth.ErrServerError)
		return
	}

	stateToken, err := h.JWTManager.GenerateStateToken(providerName, redirectURL, "", nonce, 10*time.Minute)
	if err != nil {
		h.Logger.Error("failed to generate state token",
			"provider", providerName,
			"error", err)
		h.respondWithError(c, auth.ErrServerError)
		return
	}

	secure := h.Environment == env.Production

	c.SetSameSite(http.SameSiteLaxMode)

	c.SetCookie("oidc_state", stateToken, 600, "/", "", secure, true)

	c.Redirect(http.StatusTemporaryRedirect, authURL)
}

func (h *OIDCHandler) Callback(c *gin.Context) {
	providerName := c.Param("provider")
	code := c.Query("code")
	errorParam := c.Query("error")
	stateParam := c.Query("state")

	if stateParam == "" {
		h.Logger.Warn("callback received without state parameter",
			"provider", providerName,
			"ip", c.ClientIP())
		h.respondWithError(c, auth.ErrInvalidRequest)
		return
	}

	stateToken, err := c.Cookie("oidc_state")
	if err != nil {
		h.Logger.Warn("callback received without state cookie",
			"provider", providerName)
		h.respondWithError(c, auth.ErrInvalidSession)
		return
	}

	stateClaims, err := h.JWTManager.ValidateStateToken(stateToken)
	if err != nil {
		h.Logger.Warn("invalid state token",
			"provider", providerName,
			"error", err)
		h.respondWithError(c, auth.ErrInvalidSession)
		return
	}

	redirectURL := stateClaims.RedirectURL
	nonce := stateClaims.Nonce

	if stateClaims.Provider != providerName {
		h.Logger.Warn("provider mismatch in state token",
			"expected", providerName,
			"got", stateClaims.Provider,
			"ip", c.ClientIP())
		h.redirectWithError(c, redirectURL, "invalid_session")
		return
	}

	if err := auth.ValidateRedirectURL(redirectURL, h.AllowedRedirectURLs); err != nil {
		h.Logger.Warn("invalid redirect URL in state token",
			"redirect_url", redirectURL,
			"error", err,
			"ip", c.ClientIP())
		h.respondWithError(c, auth.ErrInvalidSession)
		return
	}

	if errorParam != "" {
		errorDesc := c.Query("error_description")
		h.Logger.Warn("OIDC provider returned error",
			"provider", providerName,
			"error", errorParam,
			"description", errorDesc)
		h.redirectWithError(c, redirectURL, "authentication_cancelled")
		return
	}

	if code == "" {
		h.Logger.Warn("callback received without authorization code",
			"provider", providerName)
		h.redirectWithError(c, redirectURL, "authentication_failed")
		return
	}

	exists := h.Service.HasProvider(providerName)
	if !exists {
		h.Logger.Error("unknown OIDC provider",
			"provider", providerName)
		h.redirectWithError(c, redirectURL, "invalid_provider")
		return
	}

	secure := h.Environment == env.Production
	c.SetSameSite(http.SameSiteLaxMode)
	c.SetCookie("oidc_state", "", -1, "/", "", secure, true)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	token, err := h.Service.Exchange(ctx, providerName, code)
	if err != nil {
		h.Logger.Error("token exchange failed",
			"provider", providerName,
			"error", err)
		h.redirectWithError(c, redirectURL, "authentication_failed")
		return
	}

	var claims *oidc.IDTokenClaims
	var idTokenStr string
	if idToken, ok := token.Extra("id_token").(string); ok && idToken != "" {
		idTokenStr = idToken
		claims, err = h.Service.VerifyIDToken(ctx, providerName, idToken, nonce)
		if err != nil {
			h.Logger.Error("ID token verification failed",
				"provider", providerName,
				"error", err)
			h.redirectWithError(c, redirectURL, "authentication_failed")
			return
		}
	}

	userInfo, err := h.Service.UserInfo(ctx, providerName, token)
	if err != nil {
		h.Logger.Error("failed to fetch user info",
			"provider", providerName,
			"error", err)
		h.redirectWithError(c, redirectURL, "authentication_failed")
		return
	}

	userInfoMap, ok := userInfo.(map[string]any)
	if !ok {
		h.Logger.Warn("user info is not a map, converting",
			"provider", providerName,
			"type", fmt.Sprintf("%T", userInfo))
		userInfoMap = map[string]any{"data": userInfo}
	}

	var idTokenClaimsMap map[string]any
	if claims != nil {
		idTokenClaimsMap = map[string]any{
			"iss":                claims.Issuer,
			"sub":                claims.Subject,
			"aud":                claims.Audience,
			"exp":                claims.ExpirationTime,
			"iat":                claims.IssuedAt,
			"nonce":              claims.Nonce,
			"name":               claims.Name,
			"email":              claims.Email,
			"email_verified":     claims.EmailVerified,
			"preferred_username": claims.PreferredUsername,
			"picture":            claims.Picture,
		}
	}

	sessionToken, err := h.JWTManager.GenerateSessionToken(
		providerName,
		token.AccessToken,
		token.RefreshToken,
		userInfoMap,
		idTokenStr,
		idTokenClaimsMap,
		time.Duration(h.SessionMaxAge)*time.Second,
	)
	if err != nil {
		h.Logger.Error("failed to generate session token",
			"error", err)
		h.redirectWithError(c, redirectURL, "server_error")
		return
	}

	c.SetSameSite(http.SameSiteLaxMode)
	c.SetCookie(
		"session",
		sessionToken,
		h.SessionMaxAge,
		"/",
		"",
		secure,
		true,
	)

	h.Logger.Info("OIDC authentication successful",
		"provider", providerName)

	h.redirectWithSuccess(c, redirectURL, providerName)
}

func (h *OIDCHandler) redirectWithSuccess(c *gin.Context, baseURL, provider string) {
	u, err := url.Parse(baseURL)
	if err != nil {
		h.Logger.Error("failed to parse redirect URL", "url", baseURL, "error", err)
		h.respondWithError(c, auth.ErrConfigurationError)
		return
	}

	q := u.Query()
	q.Set("success", "true")
	q.Set("provider", provider)
	u.RawQuery = q.Encode()

	c.Redirect(http.StatusSeeOther, u.String())
}

func (h *OIDCHandler) respondWithError(c *gin.Context, authErr *auth.AuthError) {
	c.JSON(authErr.Status, gin.H{
		"error":   authErr.Code,
		"message": authErr.Message,
	})
}

func (h *OIDCHandler) redirectWithError(c *gin.Context, baseURL, errorCode string) {
	u, err := url.Parse(baseURL)
	if err != nil {
		h.Logger.Error("failed to parse redirect URL", "url", baseURL, "error", err)
		h.respondWithError(c, auth.ErrConfigurationError)
		return
	}

	q := u.Query()
	q.Set("error", errorCode)
	u.RawQuery = q.Encode()

	c.Redirect(http.StatusSeeOther, u.String())
}
