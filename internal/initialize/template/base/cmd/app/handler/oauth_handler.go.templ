package handler

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"net/url"
	"{{ .Name }}/cmd/app/service"
	"{{ .Name }}/internal/auth"
	"{{ .Name }}/internal/env"
	"time"

	"github.com/gin-gonic/gin"
)

type OAuthHandler struct {
	Service             *service.OAuthService
	Environment         env.Environment
	AllowedRedirectURLs []string
	JWTManager          *auth.JWTManager
	SessionMaxAge       int
	Logger              *slog.Logger
}

func NewOAuthHandler(s *service.OAuthService, environment env.Environment, allowedRedirectURLs []string, jwtManager *auth.JWTManager, sessionMaxAge int, logger *slog.Logger) *OAuthHandler {
	return &OAuthHandler{
		Service:             s,
		Environment:         environment,
		AllowedRedirectURLs: allowedRedirectURLs,
		JWTManager:          jwtManager,
		SessionMaxAge:       sessionMaxAge,
		Logger:              logger,
	}
}

func (h *OAuthHandler) Authorize(c *gin.Context) {
	redirectURL := c.Query("redirect_url")
	if redirectURL == "" {
		h.respondWithError(c, auth.ErrInvalidRequest)
		return
	}

	if err := auth.ValidateRedirectURL(redirectURL, h.AllowedRedirectURLs); err != nil {
		h.Logger.Warn("invalid redirect URL attempted",
			"redirect_url", redirectURL,
			"error", err,
			"ip", c.ClientIP())
		h.respondWithError(c, auth.ErrInvalidRequest)
		return
	}

	providerName := c.Param("provider")

	ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
	defer cancel()

	authURL, pkceVerifier, err := h.Service.AuthURL(ctx, providerName)
	if err != nil {
		h.Logger.Error("failed to generate auth URL",
			"provider", providerName,
			"error", err)
		h.respondWithError(c, auth.ErrServerError)
		return
	}

	stateToken, err := h.JWTManager.GenerateStateToken(providerName, redirectURL, pkceVerifier, "", 10*time.Minute)
	if err != nil {
		h.Logger.Error("failed to generate state token",
			"provider", providerName,
			"error", err)
		h.respondWithError(c, auth.ErrServerError)
		return
	}

	secure := h.Environment == env.Production

	c.SetSameSite(http.SameSiteLaxMode)

	c.SetCookie("oauth_state", stateToken, 600, "/", "", secure, true)

	c.Redirect(http.StatusTemporaryRedirect, authURL)
}

func (h *OAuthHandler) Callback(c *gin.Context) {
	providerName := c.Param("provider")
	code := c.Query("code")
	errorParam := c.Query("error")
	stateParam := c.Query("state")

	if stateParam == "" {
		h.Logger.Warn("callback received without state parameter",
			"provider", providerName,
			"ip", c.ClientIP())
		h.respondWithError(c, auth.ErrInvalidRequest)
		return
	}

	stateToken, err := c.Cookie("oauth_state")
	if err != nil {
		h.Logger.Warn("callback received without state cookie",
			"provider", providerName)
		h.respondWithError(c, auth.ErrInvalidSession)
		return
	}

	stateClaims, err := h.JWTManager.ValidateStateToken(stateToken)
	if err != nil {
		h.Logger.Warn("invalid state token",
			"provider", providerName,
			"error", err)
		h.respondWithError(c, auth.ErrInvalidSession)
		return
	}

	redirectURL := stateClaims.RedirectURL

	if stateClaims.Provider != providerName {
		h.Logger.Warn("provider mismatch in state token",
			"expected", providerName,
			"got", stateClaims.Provider,
			"ip", c.ClientIP())
		h.redirectWithError(c, redirectURL, "invalid_session")
		return
	}

	if err := auth.ValidateRedirectURL(redirectURL, h.AllowedRedirectURLs); err != nil {
		h.Logger.Warn("invalid redirect URL in state token",
			"redirect_url", redirectURL,
			"error", err,
			"ip", c.ClientIP())
		h.respondWithError(c, auth.ErrInvalidSession)
		return
	}

	if errorParam != "" {
		errorDesc := c.Query("error_description")
		h.Logger.Warn("OAuth provider returned error",
			"provider", providerName,
			"error", errorParam,
			"description", errorDesc)
		h.redirectWithError(c, redirectURL, "authentication_cancelled")
		return
	}

	if code == "" {
		h.Logger.Warn("callback received without authorization code",
			"provider", providerName)
		h.redirectWithError(c, redirectURL, "authentication_failed")
		return
	}

	exists := h.Service.HasProvider(providerName)
	if !exists {
		h.Logger.Error("unknown OAuth provider",
			"provider", providerName)
		h.redirectWithError(c, redirectURL, "invalid_provider")
		return
	}

	secure := h.Environment == env.Production
	c.SetSameSite(http.SameSiteLaxMode)
	c.SetCookie("oauth_state", "", -1, "/", "", secure, true)

	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	token, err := h.Service.Exchange(ctx, providerName, code, stateClaims.PKCEVerifier)
	if err != nil {
		h.Logger.Error("token exchange failed",
			"provider", providerName,
			"error", err)
		h.redirectWithError(c, redirectURL, "authentication_failed")
		return
	}

	userInfo, err := h.Service.UserInfo(ctx, providerName, token)
	if err != nil {
		h.Logger.Error("failed to fetch user info",
			"provider", providerName,
			"error", err)
		h.redirectWithError(c, redirectURL, "authentication_failed")
		return
	}

	userInfoMap, ok := userInfo.(map[string]any)
	if !ok {
		h.Logger.Warn("user info is not a map, converting",
			"provider", providerName,
			"type", fmt.Sprintf("%T", userInfo))
		userInfoMap = map[string]any{"data": userInfo}
	}

	sessionToken, err := h.JWTManager.GenerateSessionToken(
		providerName,
		token.AccessToken,
		token.RefreshToken,
		userInfoMap,
		"",
		nil,
		time.Duration(h.SessionMaxAge)*time.Second,
	)
	if err != nil {
		h.Logger.Error("failed to generate session token",
			"error", err)
		h.redirectWithError(c, redirectURL, "server_error")
		return
	}

	c.SetSameSite(http.SameSiteLaxMode)
	c.SetCookie(
		"session",
		sessionToken,
		h.SessionMaxAge,
		"/",
		"",
		secure,
		true,
	)

	h.Logger.Info("OAuth authentication successful",
		"provider", providerName)

	h.redirectWithSuccess(c, redirectURL, providerName)
}

func (h *OAuthHandler) redirectWithSuccess(c *gin.Context, baseURL, provider string) {
	u, err := url.Parse(baseURL)
	if err != nil {
		h.Logger.Error("failed to parse redirect URL", "url", baseURL, "error", err)
		h.respondWithError(c, auth.ErrConfigurationError)
		return
	}

	q := u.Query()
	q.Set("success", "true")
	q.Set("provider", provider)
	u.RawQuery = q.Encode()

	c.Redirect(http.StatusSeeOther, u.String())
}

func (h *OAuthHandler) respondWithError(c *gin.Context, authErr *auth.AuthError) {
	c.JSON(authErr.Status, gin.H{
		"error":   authErr.Code,
		"message": authErr.Message,
	})
}

func (h *OAuthHandler) redirectWithError(c *gin.Context, baseURL, errorCode string) {
	u, err := url.Parse(baseURL)
	if err != nil {
		h.Logger.Error("failed to parse redirect URL", "url", baseURL, "error", err)
		h.respondWithError(c, auth.ErrConfigurationError)
		return
	}

	q := u.Query()
	q.Set("error", errorCode)
	u.RawQuery = q.Encode()

	c.Redirect(http.StatusSeeOther, u.String())
}
