package service

import (
	"context"
	"log/slog"
	"{{ .Name }}/internal/auth"
	"{{ .Name }}/internal/auth/oauth"

	"golang.org/x/oauth2"
)

type OAuthService struct {
	registry *oauth.Registry
	logger   *slog.Logger
}

func NewOAuthService(registry *oauth.Registry, logger *slog.Logger) *OAuthService {
	return &OAuthService{
		registry: registry,
		logger:   logger,
	}
}

func (s *OAuthService) AuthURL(ctx context.Context, providerName string) (authURL, pkceVerifier string, err error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return "", "", oauth.ErrProviderNotFound
	}

	state, err := auth.GenerateRandomToken()
	if err != nil {
		return "", "", err
	}

	if provider.RequiresPKCE() {
		pkceChallenge, err := oauth.GeneratePKCEChallenge()
		if err != nil {
			return "", "", err
		}

		return provider.AuthURLWithPKCE(state, pkceChallenge), pkceChallenge.CodeVerifier, nil
	}

	return provider.AuthURL(state), "", nil
}

func (s *OAuthService) Exchange(ctx context.Context, providerName, code, pkceVerifier string) (*oauth2.Token, error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return nil, oauth.ErrProviderNotFound
	}

	if provider.RequiresPKCE() && pkceVerifier != "" {
		return provider.ExchangeWithPKCE(ctx, code, pkceVerifier)
	}

	return provider.Exchange(ctx, code)
}

func (s *OAuthService) UserInfo(ctx context.Context, providerName string, token *oauth2.Token) (any, error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return nil, oauth.ErrProviderNotFound
	}

	return provider.UserInfo(ctx, token)
}

func (s *OAuthService) HasProvider(name string) bool {
	_, exists := s.registry.Get(name)
	return exists
}

func (s *OAuthService) GetRedirectURL(providerName string) (string, error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return "", oauth.ErrProviderNotFound
	}
	return provider.RedirectURL(), nil
}
