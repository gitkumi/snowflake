package service

import (
	"context"
	"log/slog"
	"{{ .Name }}/internal/auth"
	"{{ .Name }}/internal/auth/oidc"

	"golang.org/x/oauth2"
)

type OIDCService struct {
	registry *oidc.Registry
	logger   *slog.Logger
}

func NewOIDCService(registry *oidc.Registry, logger *slog.Logger) *OIDCService {
	return &OIDCService{
		registry: registry,
		logger:   logger,
	}
}

func (s *OIDCService) AuthURL(ctx context.Context, providerName string) (authURL, nonce string, err error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return "", "", oidc.ErrProviderNotFound
	}

	state, err := auth.GenerateRandomToken()
	if err != nil {
		return "", "", err
	}

	nonce, err = auth.GenerateRandomToken()
	if err != nil {
		return "", "", err
	}

	return provider.AuthURL(state, nonce), nonce, nil
}

func (s *OIDCService) Exchange(ctx context.Context, providerName, code string) (*oauth2.Token, error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return nil, oidc.ErrProviderNotFound
	}

	return provider.Exchange(ctx, code)
}

func (s *OIDCService) VerifyIDToken(ctx context.Context, providerName, idToken, nonce string) (*oidc.IDTokenClaims, error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return nil, oidc.ErrProviderNotFound
	}

	claims, err := provider.VerifyIDToken(ctx, idToken)
	if err != nil {
		return nil, err
	}

	if nonce != "" && claims.Nonce != nonce {
		return nil, oidc.ErrNonceMismatch
	}

	return claims, nil
}

func (s *OIDCService) UserInfo(ctx context.Context, providerName string, token *oauth2.Token) (any, error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return nil, oidc.ErrProviderNotFound
	}
	return provider.UserInfo(ctx, token)
}

func (s *OIDCService) GetRedirectURL(providerName string) (string, error) {
	provider, exists := s.registry.Get(providerName)
	if !exists {
		return "", oidc.ErrProviderNotFound
	}
	return provider.RedirectURL(), nil
}

func (s *OIDCService) HasProvider(name string) bool {
	_, exists := s.registry.Get(name)
	return exists
}
