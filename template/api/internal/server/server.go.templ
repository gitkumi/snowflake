package server

import (
	"context"
	"database/sql"
	"{{ .Name }}/internal/data"
	"{{ .Name }}/internal/smtp"
	"{{ .Name }}/internal/storage"
	"{{ .Name }}/static"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"sync"
	"syscall"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/lmittmann/tint"
	"github.com/pressly/goose/v3"
)

type Config struct {
	BaseUrl string

	GinMode string
	Port    int

	DatabaseUrl string
	MigrateDb   bool

	Storage storage.Storage
	Mailer  smtp.Mailer
}

type Server struct {
	BaseUrl string
	Port    int

	Router  *gin.Engine
	DB      *sql.DB
	Query   *data.Queries
	Storage *storage.Storage
	Mailer  *smtp.Mailer
	Logger  *slog.Logger

	wg sync.WaitGroup
}

func Init(cfg *Config) (*Server, error) {
	db, err := sql.Open("sqlite3", cfg.DatabaseUrl)
	if err != nil {
		return nil, err
	}

	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(25)
	db.SetConnMaxLifetime(2 * time.Minute)

	if cfg.MigrateDb {
		goose.SetBaseFS(static.Migration)

		if err := goose.SetDialect("sqlite3"); err != nil {
			return nil, err
		}

		if err := goose.Up(db, "sql/migrations"); err != nil {
			return nil, err
		}
	}

	gin.SetMode(cfg.GinMode)

	router := gin.Default()
	router.Use(cors.Default())

	logger := slog.New(tint.NewHandler(os.Stdout, &tint.Options{Level: slog.LevelDebug}))

	s := &Server{
		BaseUrl: cfg.BaseUrl,
		Port:    cfg.Port,
		DB:      db,
		Query:   data.New(db),
		Router:  router,
		Storage: &cfg.Storage,
		Mailer:  &cfg.Mailer,
		Logger:  logger,
	}

	s.RegisterRoutes()

	return s, nil
}

func (s *Server) Run() error {
	srv := &http.Server{
		Addr:    ":" + strconv.Itoa(s.Port),
		Handler: s.Router,
	}

	errCh := make(chan error, 1)

	go func() {
		if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			errCh <- fmt.Errorf("listen and serve returned err: %w", err)
		}
	}()

	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	select {
	case <-ctx.Done():

	case err := <-errCh:
		return err
	}

	shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := srv.Shutdown(shutdownCtx); err != nil {
		return err
	}

	s.wg.Wait()
	return nil
}

func (s *Server) Health(c *gin.Context) {
	err := s.DB.Ping()

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "OK",
	})
}

func (s *Server) Task(fn func() error) {
	s.wg.Add(1)

	go func() {
		defer s.wg.Done()

		err := fn()
		if err != nil {
			s.Logger.Error(err.Error())
		}
	}()
}
