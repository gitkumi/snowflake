package server

import (
	"database/sql"
	"{{ .Name }}/internal/data"
	"{{ .Name }}/internal/password"
	"{{ .Name }}/internal/smtp"
	"{{ .Name }}/internal/utils"
	"net/http"
	"path"
	"time"

	"github.com/gin-gonic/gin"
	gonanoid "github.com/matoous/go-nanoid/v2"
)

func (s *Server) Register(c *gin.Context) {
	var registerParams RegisterInput
	if err := c.BindJSON(&registerParams); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	data, err := registerParams.Data()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	user, err := s.Query.CreateUser(c, data)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"data": user,
	})
}

func (s *Server) Login(c *gin.Context) {
	var login LoginInput
	if err := c.BindJSON(&login); err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": err.Error(),
		})
		return
	}

	user, err := s.Query.GetUserByEmail(c, login.Email)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Invalid username or password.",
		})
		return
	}

	if user == (data.User{}) {
		// Fake run
		_, _ = password.VerifyPassword(login.Password, "notsecure")
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Invalid username or password.",
		})
		return
	}

	match, err := password.VerifyPassword(login.Password, user.HashedPassword.String)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Invalid username or password.",
		})
		return
	}

	if !match {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Invalid username or password.",
		})
		return
	}

	tokenString, err := utils.CreateJwt(user.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"token": tokenString,
	})
}

// TODO: Make it idempotic?
func (s *Server) CreateMagicLink(c *gin.Context) {
	var magicLink CreateMagicLinkInput
	if err := c.BindJSON(&magicLink); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	user, err := s.Query.GetUserByEmail(c, magicLink.Email)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	nanoid, err := gonanoid.New()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	token, err := s.Query.CreateUserAuthToken(c, data.CreateUserAuthTokenParams{
		ID:     nanoid,
		UserID: user.ID,
		Type:   "magic_link",
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	loginURL := path.Join(s.BaseURL, "auth", "email-login", token.ID)
	s.Mailer.Send(smtp.Email{
		To: user.Email, Subject: "Login", Body: loginURL,
	})

	c.JSON(http.StatusCreated, gin.H{
		"message": "Please check your email for the magic link.",
	})
}

func (s *Server) CreateResetPassword(c *gin.Context) {
	var createResetPasswordParams CreateResetPasswordInput
	if err := c.BindJSON(&createResetPasswordParams); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	user, err := s.Query.GetUserByEmail(c, createResetPasswordParams.Email)
	if err != nil || user == (data.User{}) {
		c.Status(http.StatusNoContent)
		return
	}

	nanoid, err := gonanoid.New()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	token, err := s.Query.CreateUserAuthToken(c, data.CreateUserAuthTokenParams{
		ID:     nanoid,
		Type:   "reset_password",
		UserID: user.ID,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	resetPasswordURL := path.Join(s.BaseURL, "auth", "reset-password", token.ID)
	s.Mailer.Send(smtp.Email{
		To: user.Email, Subject: "Password Reset", Body: resetPasswordURL,
	})

	c.JSON(http.StatusOK, gin.H{
		"message": "Please check your email for the reset password link.",
	})
}

func (s *Server) CreateConfirmEmail(c *gin.Context) {
	var createConfirmEmailParams CreateConfirmEmailInput
	if err := c.BindJSON(&createConfirmEmailParams); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	user, err := s.Query.GetUserByEmail(c, createConfirmEmailParams.Email)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	nanoid, err := gonanoid.New()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}
	token, err := s.Query.CreateUserAuthToken(c, data.CreateUserAuthTokenParams{
		ID:     nanoid,
		UserID: user.ID,
		Type:   "confirm_email",
	})

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	confirmEmailURL := path.Join(s.BaseURL, "auth", "confirm-email", token.ID)
	s.Mailer.Send(smtp.Email{
		To: user.Email, Subject: "Confirm Email", Body: confirmEmailURL,
	})

	c.JSON(http.StatusOK, gin.H{
		"message": "Please check your email for the confirmation link.",
	})
}

func (s *Server) ConsumeMagicLink(c *gin.Context) {
	token, err := s.Query.GetUserAuthTokens(c, data.GetUserAuthTokensParams{
		ID:   c.Param("token"),
		Type: "magic_link",
	})

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": err.Error(),
		})
		return
	}

	tokenString, err := utils.CreateJwt(token.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"token": tokenString,
	})
}

func (s *Server) ConsumeResetPassword(c *gin.Context) {
	token, err := s.Query.GetUserAuthTokens(c, data.GetUserAuthTokensParams{
		ID:   c.Param("token"),
		Type: "reset_password",
	})

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": err.Error(),
		})
		return
	}

	var resetPasswordParams ResetPasswordInput
	if err := c.BindJSON(&resetPasswordParams); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}

	user, err := s.Query.GetUser(c, token.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	if resetPasswordParams.Email != user.Email {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid token.",
		})
		return
	}

	hashed, err := password.HashPassword(resetPasswordParams.Password)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	updated, err := s.Query.UpdateUser(c, data.UpdateUserParams{
		ID:       user.ID,
		Email:    user.Email,
		Username: user.Username,
		HashedPassword: sql.NullString{
			String: hashed,
			Valid:  true,
		},
		FirstName:   user.FirstName,
		LastName:    user.LastName,
		ConfirmedAt: user.ConfirmedAt,
	})

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, updated)
}

func (s *Server) ConsumeConfirmEmail(c *gin.Context) {
	token, err := s.Query.GetUserAuthTokens(c, data.GetUserAuthTokensParams{
		ID:   c.Param("token"),
		Type: "confirm_email",
	})

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": err.Error(),
		})
		return
	}

	user, err := s.Query.GetUser(c, token.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	confirmed, err := s.Query.UpdateUser(c, data.UpdateUserParams{
		ID:             user.ID,
		Email:          user.Email,
		Username:       user.Username,
		HashedPassword: user.HashedPassword,
		FirstName:      user.FirstName,
		LastName:       user.LastName,
		ConfirmedAt: sql.NullTime{
			Time:  time.Now(),
			Valid: true,
		},
	})

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data": createUserResponse(confirmed),
	})
}
